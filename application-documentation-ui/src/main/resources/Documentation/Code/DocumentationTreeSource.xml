<?xml version="1.1" encoding="UTF-8"?>

<!--
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
-->

<xwikidoc version="1.3" reference="Documentation.Code.DocumentationTreeSource" locale="">
  <web>Documentation.Code</web>
  <name>DocumentationTreeSource</name>
  <language/>
  <defaultLanguage>en</defaultLanguage>
  <translation>0</translation>
  <creator>xwiki:XWiki.Admin</creator>
  <creationDate>1451602800000</creationDate>
  <parent>Main.WebHome</parent>
  <author>xwiki:XWiki.Admin</author>
  <contentAuthor>xwiki:XWiki.Admin</contentAuthor>
  <date>1451602800000</date>
  <contentUpdateDate>1451602800000</contentUpdateDate>
  <version>1.1</version>
  <title>DocumentationTreeSource</title>
  <comment/>
  <minorEdit>false</minorEdit>
  <syntaxId>xwiki/2.1</syntaxId>
  <hidden>false</hidden>
  <content>{{include reference="XWiki.SuggestSolrMacros" /}}

{{template name="documentTree_macros.vm" /}}

{{velocity output="false"}}
## Most of the code was taken from XWiki.DocumentTree and then reduced to serve the only use case that we have now
## Customized sections are surrounded by markers to clearly see where the code has been changed.
#macro (updateDocTreeConfigFromRequest)
  #foreach ($entry in $docTreeConfig.entrySet())
    #set ($valueFromRequest = $request.getParameter($entry.key))
    #if ("$!valueFromRequest" != '')
      #if ($entry.value.getClass().getName() == 'java.lang.Boolean')
        #set ($entry.value = $valueFromRequest == 'true')
      #elseif ($entry.value.iterator())
        #set ($valuesFromRequest = $request.getParameterValues($entry.key))
        #set ($discard = $entry.value.clear())
        ## We need to convert the String[] to List&lt;String&gt; before calling addAll (which expects a collection).
        #set ($discard = $entry.value.addAll($valuesFromRequest.subList(0, $valuesFromRequest.size())))
      #else
        #set ($entry.value = $valueFromRequest)
      #end
    #end
  #end
  ## Show the wikis only for global users.
  #set ($docTreeConfig.showWikis = $docTreeConfig.showWikis &amp;&amp;
    $xcontext.userReference.wikiReference.name == $xcontext.mainWikiName)
  #if ("$!docTreeConfig.root" == '')
    #if ($docTreeConfig.showWikis)
      #set ($docTreeConfig.root = 'farm:*')
    #else
      #set ($docTreeConfig.root = "wiki:$xcontext.database")
    #end
  #end
  ## Handle relative references
  #makeNodeReferencesAbsolute($docTreeConfig ['root', 'openTo'])
  ## Sort the child documents by (raw) title when the node label is the document title.
  #if ($docTreeConfig.showDocumentTitle)
    #set ($docTreeConfig.orderBy = 'title')
  #end
  ## Determine which hierarchy needs to be used.
  #if ($docTreeConfig.showSpaces)
    #if ($docTreeConfig.hierarchyMode == 'parentchild')
      #set ($tree = $services.tree.parentChildOnNestedSpaces)
    #else
      #set ($tree = $services.tree.nestedSpaces)
    #end
  #elseif ($docTreeConfig.hierarchyMode == 'parentchild')
    #set ($tree = $services.tree.parentChild)
  #else
    #set ($tree = $services.tree.nestedPages)
  #end
  #set ($discard = $tree.properties.putAll($docTreeConfig))
#end

#macro (makeNodeReferencesAbsolute $map $keys)
  #foreach ($key in $keys)
    #set ($nodeId = $map.get($key))
    #set ($parts = $nodeId.split(':', 2))
    #if ($parts &amp;&amp; $parts.size() == 2)
      #set ($nodeType = $parts[0].toLowerCase())
      #set ($nodeReference = $parts[1])
      #set ($entityType = $nodeType)
      #set ($discard = "#evaluate(""${escapetool.h}set (${escapetool.d}entityReference =
        ${escapetool.d}services.model.resolve$stringtool.capitalize($entityType)(${escapetool.d}nodeReference))"")")
      #if ($entityReference)
        #set ($nodeReference = $services.model.serialize($entityReference, 'default'))
      #end
      #set ($discard = $map.put($key, "$nodeType:$nodeReference"))
    #end
  #end
#end

#macro (handleDocumentTreeRequest)
  #if ($request.action)
    #if ($services.csrf.isTokenValid($request.form_token))
      $response.sendError(400, 'The specified action is not supported.')
    #elseif ($isAjaxRequest)
      $response.sendError(403, 'The CSRF token is missing.')
    #else
      $response.sendRedirect($services.csrf.getResubmissionURL())
    #end
  #else
    #set ($data = $NULL)
    #if ($request.data == 'children')
      #getChildren($request.id $data)
    #end
    #if ($data)
      #jsonResponse($data)
    #else
      $response.sendError(404)
    #end
  #end
#end

##------------------------------------------------------------
## Children
##------------------------------------------------------------

#macro (getChildren $nodeId $return)
  #set ($children = [])
  #if ($nodeId == '#')
    ## Return the top level nodes.
    #set ($actualNodeId = $docTreeConfig.root)
  #else
    ## Return the children of the specified node.
    #set ($actualNodeId = $nodeId)
  #end
  #set ($offset = $mathtool.max($mathtool.toInteger($request.offset), 0))
  #if ("$!offset" == '')
    #set ($offset = 0)
  #end
  #set ($limit = $mathtool.max($mathtool.toInteger($request.limit), 1))
  #if ("$!limit" == '')
    #set ($limit = 15)
  #end
  #if ($nodeId == '#' &amp;&amp; $docTreeConfig.showRoot)
    #maybeAddNode($actualNodeId $children)
  #else
    #addChildNodes($actualNodeId $offset $limit $children)
  #end
  #if ($children.isEmpty() &amp;&amp; $nodeId == '#')
    ## Inform the user that the tree is empty.
    #addEmptyTreeNode($children)
  #end
  #set ($return = $NULL)
  #setVariable("$return" $children)
#end

#macro (maybeAddNode $nodeId $siblings $placeholder)
  #set ($parts = $nodeId.split(':', 2))
  #if ($parts &amp;&amp; $parts.size() == 2)
    #set ($nodeType = $parts[0])
    #set ($nodeReference = $parts[1])
    #if ($nodeType == 'child' || $nodeType == 'document')
      #set ($discard = "#evaluate(""${escapetool.h}maybeAdd$stringtool.capitalize($nodeType)Node(
        ${escapetool.d}nodeReference ${escapetool.d}siblings ${escapetool.d}placeholder)"")")
    #end
  #end
#end

#macro (addChildNodes $nodeId $offset $limit $children)
  ## Avoid pages with only one node when paginating the child nodes.
  #set ($actualLimit = $limit + 1)

  ## ********** Start of customization **********
  #set ($parts = $nodeId.split(':', 3))
  ## Constraint the root of the tree to a document in the current wiki
  #if ($parts &amp;&amp; $parts.size() == 3 &amp;&amp; $parts[0] == 'document' &amp;&amp; $parts[1] == $services.wiki.currentWikiId)
    #set($results = $services.query.hql("select distinct obj.name from BaseObject obj, StringProperty parent, LongProperty numbering where obj.className = 'Documentation.Code.SectionClass' and obj.id = parent.id.id and obj.id = numbering.id.id and numbering.id.name = 'numbering' and parent.id.name = 'parentSection' and parent.value = :parentValue order by numbering.value asc").bindValue('parentValue', $parts[2]).execute())
    #set($childNodeIds = [])
    #foreach ($result in $results)
      #set($discard = $childNodeIds.add("document:$result"))
    #end
  ## ********** End of customization **********

    #set ($hasMoreChildNodes = false)
    #if ($childNodeIds.size() &gt;= $actualLimit)
      #set ($totalCount = $tree.getChildCount($nodeId))
      #set ($newOffset = $offset + $actualLimit)
      #if ($newOffset &lt; $totalCount)
        ## There are at least 2 more child nodes.
        #set ($hasMoreChildNodes = true)
        #set ($newOffset = $newOffset - 1)
        #set ($childNodeIds = $childNodeIds.subList(0, $limit))
      #end
    #end
    #foreach ($childNodeId in $childNodeIds)
      #maybeAddNode($childNodeId $children)
    #end
    #if ($hasMoreChildNodes)
      #addPaginationNode($nodeId $newOffset $totalCount $children)
    #end
  ## ********** Start of customization **********
  #end
  ## ********** End of customization **********
#end


##
## Document Nodes
##

#macro (maybeAddDocumentNode $documentIdOrReference $siblings $placeholder)
  #if ($documentIdOrReference.type)
    #set ($documentReference = $documentIdOrReference)
  #else
    #set ($documentReference = $services.model.resolveDocument($documentIdOrReference))
  #end
  #if (!$docTreeConfig.showOnlyViewable || $services.security.authorization.hasAccess('view', $documentReference))
    #addDocumentNode($documentReference $siblings)
  #elseif ($placeholder)
    #set ($discard = $siblings.add($placeholder))
  #end
#end

#macro (addDocumentNode $documentReference $siblings)
  #set ($documentId = $services.model.serialize($documentReference, 'default'))
  #set ($label = $documentReference.name)
  #if (!$docTreeConfig.showSpaces &amp;&amp;
      $documentReference.name == $services.model.getEntityReference('DOCUMENT', 'default').name)
    ## Use the space name as default value for the node label (in case the document is not viewable).
    #set ($label = $documentReference.parent.name)
  #end
  #set ($canViewDoc = $services.security.authorization.hasAccess('view', $documentReference))
  #set ($canDeleteDoc = $services.security.authorization.hasAccess('delete', $documentReference))
  #if ($canViewDoc &amp;&amp; $docTreeConfig.showDocumentTitle)
    ## Display the translated title.
    #set ($translatedDocument = $xwiki.getDocument($documentReference).translatedDocument)
    ## Make sure the displayed title is not affected by the sheet request parameter (e.g. when $translatedDocument is
    ## the current document). By setting the title (even if we don't change it) the internal document instance is cloned
    ## so it's going to be different than the current document instance (which is the target of the sheet parameter).
    #set ($discard = $translatedDocument.setTitle($translatedDocument.title))
    #set ($plainTitle = $translatedDocument.plainTitle)
    #if (!$stringtool.isBlank($plainTitle))
      #set ($label = $plainTitle)
    #end
  #end
  #set ($hasChildren = $tree.getChildCount("document:$documentId") &gt; 0)
  #set ($discard = $siblings.add({
    'id': "document:$documentId",
    'text': $label,
    'icon': 'fa fa-file-o',
    'children': $hasChildren,
    'data': {
      'id': $services.model.serialize($documentReference, 'default'),
      'type': 'document',
      'validChildren': ['translations', 'attachments', 'attachment', 'classProperties', 'objects', 'document', 'pagination'],
      'hasContextMenu': true,
      'draggable': $canViewDoc,
      'canDelete': $canDeleteDoc,
      'canMove': $canDeleteDoc,
      'canCopy': $canViewDoc,
      'createDocumentURL': $xwiki.getURL($documentReference, 'create', $NULL)
    },
    'a_attr': {
      'href': $xwiki.getURL($documentReference)
    }
  }))
#end

##
## Pagination Nodes
##

#macro (addPaginationNode $parentId $offset $totalCount $siblings)
  #set ($discard = $siblings.add({
    'id': "pagination:$parentId",
    'text': $services.localization.render('index.documentTree.more', $!mathtool.sub($totalCount, $offset)),
    'icon': 'fa fa-eye',
    'children': false,
    'data': {
      'type': 'pagination',
      'validChildren': [],
      'canDelete': true,
      'offset': $offset
    }
  }))
#end

##
## Empty Tree Node
##

#macro (addEmptyTreeNode $siblings)
  #set ($discard = $siblings.add({
    'id': "empty",
    'text': $services.localization.render('index.documentTree.empty'),
    'icon': 'fa fa-info-circle',
    'children': false,
    'data': {
      'type': 'empty',
      'validChildren': []
    }
  }))
#end

#macro (limitTotalCount $lists $limit)
  ## Prepare the input.
  #set ($input = [])
  #foreach ($list in $lists)
    ## We use queues to be able to easily remove items from the start.
    #set ($queue = $collectionstool.queue)
    #set ($discard = $queue.addAll($list))
    #set ($discard = $input.add($queue))
    ## We will add (part of) the items back later.
    #set ($discard = $list.clear())
  #end
  ## Limit the total item count.
  #set ($index = -1)
  #foreach ($count in [1..$limit])
    #foreach ($i in [1..$input.size()])
      #set ($newIndex = ($index + $i) % $input.size())
      #if ($input.get($newIndex).size() &gt; 0)
        #set ($index = $newIndex)
        #break
      #end
    #end
    #if ($index &lt; 0 || $input.get($index).isEmpty())
      #break
    #else
      #set ($discard = $lists.get($index).add($input.get($index).poll()))
    #end
  #end
#end
{{/velocity}}

{{velocity wiki="false"}}
#if ($xcontext.action == 'get')
  #updateDocTreeConfigFromRequest
  #handleDocumentTreeRequest
#end
{{/velocity}}</content>
</xwikidoc>
